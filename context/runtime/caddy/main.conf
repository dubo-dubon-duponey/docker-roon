{
	#	{$debug}
	https_port {$PORT}
	default_sni {$DOMAIN}
	admin off
	storage file_system {
		root "/certs"
	}
	auto_https disable_redirects
}

https://{$DOMAIN} {
	tls {$TLS} {
    client_auth {
      mode {$MTLS_MODE}
      # Technically could/should be a different root cert
      # Ideally, a separate caddy would be in charge of delivering client certs on demand maybe against credentials?
      # Of course that would downgrade the cert auth to that of the credentials then... So, for now, keep it manual / out of band
      trusted_ca_cert_file "/certs/pki/authorities/local/root.crt"
    }
	}

	log {
		output stdout
		format json
		level {$LOG_LEVEL}
	}

	# https://securityheaders.com/
	header {
		X-Xss-Protection "1; mode=block"

		# clickjacking protection
		X-Frame-Options DENY

		# disable clients from sniffing the media type
		X-Content-Type-Options nosniff

		# keep referrer data off of HTTP connections
		# Referrer-Policy no-referrer-when-downgrade
		# Referrer-Policy "same-origin"
		Referrer-Policy "strict-origin-when-cross-origin"

		# enable HSTS
		Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"

		# CSP
		Content-Security-Policy "default-src 'self';"

		# Signature
		Server "DuboDubonDuponey/1.0 (Caddy/2)"
	}

  # XXX to be replaced by SSO / something better
	basicauth bcrypt "{$REALM}" {
		{$USERNAME} {$PASSWORD}
	}

	reverse_proxy http://127.0.0.1:9100
}

# Healthcheck
{$HEALTHCHECK_URL} {
	reverse_proxy http://127.0.0.1:9100
}
